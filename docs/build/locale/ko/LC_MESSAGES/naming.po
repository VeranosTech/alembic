# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2010-2019, Mike Bayer
# This file is distributed under the same license as the Alembic package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2019.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Alembic 1.0.8\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-03-04 13:27+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.6.0\n"

#: ../naming.rst:4
msgid "The Importance of Naming Constraints"
msgstr ""

#: ../naming.rst:6
msgid ""
"An important topic worth mentioning is that of constraint naming "
"conventions. As we've proceeded here, we've talked about adding tables "
"and columns, and we've also hinted at lots of other operations listed in "
":ref:`ops` such as those which support adding or dropping constraints "
"like foreign keys and unique constraints.   The way these constraints are"
" referred to in migration scripts is by name, however these names by "
"default are in most cases generated by the relational database in use, "
"when the constraint is created.  For example, if you emitted two CREATE "
"TABLE statements like this on Postgresql::"
msgstr ""

#: ../naming.rst:22
msgid ""
"Suppose we wanted to DROP the REFERENCES that we just applied to the "
"``user_order.user_account_id`` column, how do we do that?  At the prompt,"
" we'd use ``ALTER TABLE <tablename> DROP CONSTRAINT <constraint_name>``, "
"or if using Alembic we'd be using :meth:`.Operations.drop_constraint`.  "
"But both of those functions need a name - what's the name of this "
"constraint?"
msgstr ""

#: ../naming.rst:28
msgid ""
"It does have a name, which in this case we can figure out by looking at "
"the Postgresql catalog tables::"
msgstr ""

#: ../naming.rst:41
msgid ""
"The name above is not something that Alembic or SQLAlchemy created; "
"``user_order_user_account_id_fkey`` is a naming scheme used internally by"
" Postgresql to name constraints that are otherwise not named."
msgstr ""

#: ../naming.rst:45
msgid ""
"This scheme doesn't seem so complicated, and we might want to just use "
"our knowledge of it so that we know what name to use for our "
":meth:`.Operations.drop_constraint` call.  But is that a good idea?   "
"What if for example we needed our code to run on Oracle as well.  OK, "
"certainly Oracle uses this same scheme, right?  Or if not, something "
"similar.  Let's check::"
msgstr ""

#: ../naming.rst:71
msgid ""
"Oh, we can see that is.....much worse.  Oracle's names are entirely "
"unpredictable alphanumeric codes, and this will make being able to write "
"migrations quite tedious, as we'd need to look up all these names."
msgstr ""

#: ../naming.rst:75
msgid ""
"The solution to having to look up names is to make your own names.   This"
" is an easy, though tedious thing to do manually.  For example, to create"
" our model in SQLAlchemy ensuring we use names for foreign key "
"constraints would look like::"
msgstr ""

#: ../naming.rst:93
msgid ""
"Simple enough, though this has some disadvantages.  The first is that "
"it's tedious; we need to remember to use a name for every "
":class:`~sqlalchemy.schema.ForeignKey` object, not to mention every "
":class:`~sqlalchemy.schema.UniqueConstraint`, "
":class:`~sqlalchemy.schema.CheckConstraint`, "
":class:`~sqlalchemy.schema.Index`, and maybe even "
":class:`~sqlalchemy.schema.PrimaryKeyConstraint` as well if we wish to be"
" able to alter those too, and beyond all that, all the names have to be "
"globally unique.   Even with all that effort, if we have a naming scheme "
"in mind, it's easy to get it wrong when doing it manually each time."
msgstr ""

#: ../naming.rst:101
msgid ""
"What's worse is that manually naming constraints (and indexes) gets even "
"more tedious in that we can no longer use convenience features such as "
"the ``.unique=True`` or ``.index=True`` flag on "
":class:`~sqlalchemy.schema.Column`::"
msgstr ""

#: ../naming.rst:110
msgid ""
"Above, the ``unique=True`` flag creates a "
":class:`~sqlalchemy.schema.UniqueConstraint`, but again, it's not named."
"   If we want to name it, manually we have to forego the usage of "
"``unique=True`` and type out the whole constraint::"
msgstr ""

#: ../naming.rst:120
msgid ""
"There's a solution to all this naming work, which is to use an "
"**automated naming convention**.  For some years, SQLAlchemy has "
"encourgaged the use of DDL Events in order to create naming schemes.  The"
" :meth:`~sqlalchemy.events.DDLEvents.after_parent_attach` event in "
"particular is the best place to intercept when "
":class:`~sqlalchemy.schema.Constraint` and "
":class:`~sqlalchemy.schema.Index` objects are being associated with a "
"parent :class:`~sqlalchemy.schema.Table` object, and to assign a "
"``.name`` to the constraint while making use of the name of the table and"
" associated columns."
msgstr ""

#: ../naming.rst:128
msgid ""
"But there is also a better way to go, which is to make use of a feature "
"new in SQLAlchemy 0.9.2 which makes use of the events behind the scenes "
"known as :paramref:`~sqlalchemy.schema.MetaData.naming_convention`.   "
"Here, we can create a new :class:`~sqlalchemy.schema.MetaData` object "
"while passing a dictionary referring to a naming scheme::"
msgstr ""

#: ../naming.rst:144
msgid ""
"If we define our models using a :class:`~sqlalchemy.schema.MetaData` as "
"above, the given naming convention dictionary will be used to provide "
"names for all constraints and indexes."
msgstr ""

#: ../naming.rst:151
msgid "Integration of Naming Conventions into Operations, Autogenerate"
msgstr ""

#: ../naming.rst:153
msgid ""
"As of Alembic 0.6.4, the naming convention feature is integrated into the"
" :class:`.Operations` object, so that the convention takes effect for any"
" constraint that is otherwise unnamed.  The naming convention is passed "
"to :class:`.Operations` using the "
":paramref:`.MigrationsContext.configure.target_metadata` parameter in "
"``env.py``, which is normally configured when autogenerate is used::"
msgstr ""

#: ../naming.rst:189
msgid "Above, when we render a directive like the following::"
msgstr ""

#: ../naming.rst:193
msgid ""
"The Boolean type will render a CHECK constraint with the name "
"``\"ck_sometable_q_bool\"``, assuming the backend in use does not support"
" native boolean types."
msgstr ""

#: ../naming.rst:197
msgid ""
"We can also use op directives with constraints and not give them a name "
"at all, if the naming convention doesn't require one.  The value of "
"``None`` will be converted into a name that follows the appopriate naming"
" conventions::"
msgstr ""

#: ../naming.rst:205
msgid ""
"When autogenerate renders constraints in a migration script, it renders "
"them typically with their completed name.  If using at least Alembic "
"0.6.4 as well as SQLAlchemy 0.9.4, these will be rendered with a special "
"directive :meth:`.Operations.f` which denotes that the string has already"
" been tokenized::"
msgstr ""

#: ../naming.rst:215
msgid ""
"For more detail on the naming convention feature, see "
":ref:`sqla:constraint_naming_conventions`."
msgstr ""

