# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2010-2019, Mike Bayer
# This file is distributed under the same license as the Alembic package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2019.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Alembic 1.0.8\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-03-04 13:27+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.6.0\n"

#: ../autogenerate.rst:2
msgid "Auto Generating Migrations"
msgstr ""

#: ../autogenerate.rst:4
msgid ""
"Alembic can view the status of the database and compare against the table"
" metadata in the application, generating the \"obvious\" migrations based"
" on a comparison.  This is achieved using the ``--autogenerate`` option "
"to the ``alembic revision`` command, which places so-called *candidate* "
"migrations into our new migrations file.  We review and modify these by "
"hand as needed, then proceed normally."
msgstr ""

#: ../autogenerate.rst:10
msgid ""
"To use autogenerate, we first need to modify our ``env.py`` so that it "
"gets access to a table metadata object that contains the target.  Suppose"
" our application has a :ref:`declarative base "
"<sqla:declarative_toplevel>` in ``myapp.mymodel``.  This base contains a "
":class:`~sqlalchemy.schema.MetaData` object which contains "
":class:`~sqlalchemy.schema.Table` objects defining our database.  We make"
" sure this is loaded in ``env.py`` and then passed to "
":meth:`.EnvironmentContext.configure` via the ``target_metadata`` "
"argument.   The ``env.py`` sample script used in the generic template "
"already has a variable declaration near the top for our convenience, "
"where we replace ``None`` with our :class:`~sqlalchemy.schema.MetaData`."
"  Starting with::"
msgstr ""

#: ../autogenerate.rst:27
msgid "we change to::"
msgstr ""

#: ../autogenerate.rst:34
msgid ""
"The above example refers to the **generic alembic env.py template**, e.g."
" the one created by default when calling upon ``alembic init``, and not "
"the special-use templates such as ``multidb``.   Please consult the "
"source code and comments within the ``env.py`` script directly for "
"specific guidance on where and how the autogenerate metadata is "
"established."
msgstr ""

#: ../autogenerate.rst:40
msgid ""
"If we look later in the script, down in ``run_migrations_online()``, we "
"can see the directive passed to :meth:`.EnvironmentContext.configure`::"
msgstr ""

#: ../autogenerate.rst:56
msgid ""
"We can then use the ``alembic revision`` command in conjunction with the "
"``--autogenerate`` option.  Suppose our "
":class:`~sqlalchemy.schema.MetaData` contained a definition for the "
"``account`` table, and the database did not.  We'd get output like::"
msgstr ""

#: ../autogenerate.rst:65
msgid ""
"We can then view our file ``27c6a30d7c24.py`` and see that a rudimentary "
"migration is already present::"
msgstr ""

#: ../autogenerate.rst:100
msgid ""
"The migration hasn't actually run yet, of course.  We do that via the "
"usual ``upgrade`` command.   We should also go into our migration file "
"and alter it as needed, including adjustments to the directives as well "
"as the addition of other directives which these may be dependent on - "
"specifically data changes in between creates/alters/drops."
msgstr ""

#: ../autogenerate.rst:106
msgid "What does Autogenerate Detect (and what does it *not* detect?)"
msgstr ""

#: ../autogenerate.rst:108
msgid ""
"The vast majority of user issues with Alembic centers on the topic of "
"what kinds of changes autogenerate can and cannot detect reliably, as "
"well as how it renders Python code for what it does detect.     it is "
"critical to note that **autogenerate is not intended to be perfect**.   "
"It is *always* necessary to manually review and correct the **candidate "
"migrations** that autogenererate produces.   The feature is getting more "
"and more comprehensive and error-free as releases continue, but one "
"should take note of the current limitations."
msgstr ""

#: ../autogenerate.rst:117
msgid "Autogenerate **will detect**:"
msgstr ""

#: ../autogenerate.rst:119
msgid "Table additions, removals."
msgstr ""

#: ../autogenerate.rst:120
msgid "Column additions, removals."
msgstr ""

#: ../autogenerate.rst:121
msgid "Change of nullable status on columns."
msgstr ""

#: ../autogenerate.rst:122
msgid "Basic changes in indexes and explcitly-named unique constraints"
msgstr ""

#: ../autogenerate.rst:124
msgid "Support for autogenerate of indexes and unique constraints."
msgstr ""

#: ../autogenerate.rst:126
msgid "Basic changes in foreign key constraints"
msgstr ""

#: ../autogenerate.rst:128
msgid "Support for autogenerate of foreign key constraints."
msgstr ""

#: ../autogenerate.rst:130
msgid "Autogenerate can **optionally detect**:"
msgstr ""

#: ../autogenerate.rst:132
msgid ""
"Change of column type.  This will occur if you set the "
":paramref:`.EnvironmentContext.configure.compare_type` parameter to "
"``True``, or to a custom callable function. The feature works well in "
"most cases, but is off by default so that it can be tested on the target "
"schema first.  It can also be customized by passing a callable here; see "
"the section :ref:`compare_types` for details."
msgstr ""

#: ../autogenerate.rst:139
msgid ""
"Change of server default.  This will occur if you set the "
":paramref:`.EnvironmentContext.configure.compare_server_default` "
"parameter to ``True``, or to a custom callable function. This feature "
"works well for simple cases but cannot always produce accurate results.  "
"The Postgresql backend will actually invoke the \"detected\" and "
"\"metadata\" values against the database to determine equivalence.  The "
"feature is off by default so that it can be tested on the target schema "
"first.  Like type comparison, it can also be customized by passing a "
"callable; see the function's documentation for details."
msgstr ""

#: ../autogenerate.rst:150
msgid "Autogenerate **can not detect**:"
msgstr ""

#: ../autogenerate.rst:152
msgid ""
"Changes of table name.   These will come out as an add/drop of two "
"different tables, and should be hand-edited into a name change instead."
msgstr ""

#: ../autogenerate.rst:154
msgid ""
"Changes of column name.  Like table name changes, these are detected as a"
" column add/drop pair, which is not at all the same as a name change."
msgstr ""

#: ../autogenerate.rst:156
msgid ""
"Anonymously named constraints.  Give your constraints a name, e.g. "
"``UniqueConstraint('col1', 'col2', name=\"my_name\")``.  See the section "
":doc:`naming` for background on how to configure automatic naming schemes"
" for constraints."
msgstr ""

#: ../autogenerate.rst:160
msgid ""
"Special SQLAlchemy types such as :class:`~sqlalchemy.types.Enum` when "
"generated on a backend which doesn't support ENUM directly - this because"
" the representation of such a type in the non-supporting database, i.e. a"
" CHAR+ CHECK constraint, could be any kind of CHAR+CHECK.  For SQLAlchemy"
" to determine that this is actually an ENUM would only be a guess, "
"something that's generally a bad idea. To implement your own \"guessing\""
" function here, use the "
":meth:`sqlalchemy.events.DDLEvents.column_reflect` event to detect when a"
" CHAR (or whatever the target type is) is reflected, and change it to an "
"ENUM (or whatever type is desired) if it is known that that's the intent "
"of the type.  The :meth:`sqlalchemy.events.DDLEvents.after_parent_attach`"
" can be used within the autogenerate process to intercept and un-attach "
"unwanted CHECK constraints."
msgstr ""

#: ../autogenerate.rst:175
msgid "Autogenerate can't currently, but **will eventually detect**:"
msgstr ""

#: ../autogenerate.rst:177
msgid ""
"Some free-standing constraint additions and removals may not be "
"supported, including PRIMARY KEY, EXCLUDE, CHECK; these are not "
"necessarily implemented within the autogenerate detection system and also"
" may not be supported by the supporting SQLAlchemy dialect."
msgstr ""

#: ../autogenerate.rst:181
msgid "Sequence additions, removals - not yet implemented."
msgstr ""

#: ../autogenerate.rst:184
msgid "Autogenerating Multiple MetaData collections"
msgstr ""

#: ../autogenerate.rst:186
msgid ""
"The ``target_metadata`` collection may also be defined as a sequence if "
"an application has multiple :class:`~sqlalchemy.schema.MetaData` "
"collections involved::"
msgstr ""

#: ../autogenerate.rst:194
msgid ""
"The sequence of :class:`~sqlalchemy.schema.MetaData` collections will be "
"consulted in order during the autogenerate process.  Note that each "
":class:`~sqlalchemy.schema.MetaData` must contain **unique** table keys "
"(e.g. the \"key\" is the combination of the table's name and schema); if "
"two :class:`~sqlalchemy.schema.MetaData` objects contain a table with the"
" same schema/name combination, an error is raised."
msgstr ""

#: ../autogenerate.rst:201
msgid ""
"the :paramref:`.EnvironmentContext.configure.target_metadata` parameter "
"may now be passed a sequence of :class:`~sqlalchemy.schema.MetaData` "
"objects to support autogeneration of multiple "
":class:`~sqlalchemy.schema.MetaData` collections."
msgstr ""

#: ../autogenerate.rst:209
msgid "Comparing and Rendering Types"
msgstr ""

#: ../autogenerate.rst:211
msgid ""
"The area of autogenerate's behavior of comparing and rendering Python-"
"based type objects in migration scripts presents a challenge, in that "
"there's a very wide variety of types to be rendered in scripts, including"
" those part of SQLAlchemy as well as user-defined types.   A few options "
"are given to help out with this task."
msgstr ""

#: ../autogenerate.rst:220
msgid "Controlling the Module Prefix"
msgstr ""

#: ../autogenerate.rst:222
msgid ""
"When types are rendered, they are generated with a **module prefix**, so "
"that they are available based on a relatively small number of imports. "
"The rules for what the prefix is is based on the kind of datatype as well"
" as configurational settings.   For example, when Alembic renders "
"SQLAlchemy types, it will by default prefix the type name with the prefix"
" ``sa.``::"
msgstr ""

#: ../autogenerate.rst:230
msgid ""
"The use of the ``sa.`` prefix is controllable by altering the value of "
":paramref:`.EnvironmentContext.configure.sqlalchemy_module_prefix`::"
msgstr ""

#: ../autogenerate.rst:245
msgid ""
"In either case, the ``sa.`` prefix, or whatever prefix is desired, should"
" also be included in the imports section of ``script.py.mako``; it also "
"defaults to ``import sqlalchemy as sa``."
msgstr ""

#: ../autogenerate.rst:250
msgid ""
"For user-defined types, that is, any custom type that is not within the "
"``sqlalchemy.`` module namespace, by default Alembic will use the **value"
" of __module__ for the custom type**::"
msgstr ""

#: ../autogenerate.rst:256
msgid ""
"The imports for the above type again must be made present within the "
"migration, either manually, or by adding it to ``script.py.mako``."
msgstr ""

#: ../autogenerate.rst:259
msgid ""
"The default module prefix rendering for a user-defined type now makes use"
" of the type's ``__module__`` attribute to retrieve the prefix, rather "
"than using the value of "
":paramref:`~.EnvironmentContext.configure.sqlalchemy_module_prefix`."
msgstr ""

#: ../autogenerate.rst:266
msgid ""
"The above custom type has a long and cumbersome name based on the use of "
"``__module__`` directly, which also implies that lots of imports would be"
" needed in order to accomodate lots of types.  For this reason, it is "
"recommended that user-defined types used in migration scripts be made "
"available from a single module.  Suppose we call it "
"``myapp.migration_types``::"
msgstr ""

#: ../autogenerate.rst:276
msgid ""
"We can first add an import for ``migration_types`` to our "
"``script.py.mako``::"
msgstr ""

#: ../autogenerate.rst:283
msgid ""
"We then override Alembic's use of ``__module__`` by providing a fixed "
"prefix, using the "
":paramref:`.EnvironmentContext.configure.user_module_prefix` option::"
msgstr ""

#: ../autogenerate.rst:299
msgid "Above, we now would get a migration like::"
msgstr ""

#: ../autogenerate.rst:303
msgid ""
"Now, when we inevitably refactor our application to move ``MyCustomType``"
" somewhere else, we only need modify the ``myapp.migration_types`` "
"module, instead of searching and replacing all instances within our "
"migration scripts."
msgstr ""

#: ../autogenerate.rst:307
msgid "Added :paramref:`.EnvironmentContext.configure.user_module_prefix`."
msgstr ""

#: ../autogenerate.rst:312
msgid "Affecting the Rendering of Types Themselves"
msgstr ""

#: ../autogenerate.rst:314
msgid ""
"The methodology Alembic uses to generate SQLAlchemy and user-defined type"
" constructs as Python code is plain old ``__repr__()``.   SQLAlchemy's "
"built-in types for the most part have a ``__repr__()`` that faithfully "
"renders a Python-compatible constructor call, but there are some "
"exceptions, particularly in those cases when a constructor accepts "
"arguments that aren't compatible with ``__repr__()``, such as a pickling "
"function."
msgstr ""

#: ../autogenerate.rst:321
msgid ""
"When building a custom type that will be rendered into a migration "
"script, it is often necessary to explicitly give the type a "
"``__repr__()`` that will faithfully reproduce the constructor for that "
"type.   This, in combination with "
":paramref:`.EnvironmentContext.configure.user_module_prefix`, is usually "
"enough.  However, if additional behaviors are needed, a more "
"comprehensive hook is the "
":paramref:`.EnvironmentContext.configure.render_item` option. This hook "
"allows one to provide a callable function within ``env.py`` that will "
"fully take over how a type is rendered, including its module prefix::"
msgstr ""

#: ../autogenerate.rst:351
#, python-format
msgid ""
"In the above example, we'd ensure our ``MySpecialType`` includes an "
"appropriate ``__repr__()`` method, which is invoked when we call it "
"against ``\"%r\"``."
msgstr ""

#: ../autogenerate.rst:354
msgid ""
"The callable we use for "
":paramref:`.EnvironmentContext.configure.render_item` can also add "
"imports to our migration script.  The :class:`.AutogenContext` passed in "
"contains a datamember called :attr:`.AutogenContext.imports`, which is a "
"Python ``set()`` for which we can add new imports.  For example, if "
"``MySpecialType`` were in a module called ``mymodel.types``, we can add "
"the import for it as we encounter the type::"
msgstr ""

#: ../autogenerate.rst:372
msgid ""
"The ``autogen_context`` data member passed to the ``render_item`` "
"callable is now an instance of :class:`.AutogenContext`."
msgstr ""

#: ../autogenerate.rst:375
msgid ""
"The \"imports\" data member of the autogen context is restored to the new"
" :class:`.AutogenContext` object as :attr:`.AutogenContext.imports`."
msgstr ""

#: ../autogenerate.rst:379
msgid ""
"The finished migration script will include our imports where the "
"``${imports}`` expression is used, producing output such as::"
msgstr ""

#: ../autogenerate.rst:393
msgid "Comparing Types"
msgstr ""

#: ../autogenerate.rst:395
msgid ""
"The default type comparison logic will work for SQLAlchemy built in types"
" as well as basic user defined types.   This logic is only enabled if the"
" :paramref:`.EnvironmentContext.configure.compare_type` parameter is set "
"to True::"
msgstr ""

#: ../autogenerate.rst:405
msgid ""
"Alternatively, the :paramref:`.EnvironmentContext.configure.compare_type`"
" parameter accepts a callable function which may be used to implement "
"custom type comparison logic, for cases such as where special user "
"defined types are being used::"
msgstr ""

#: ../autogenerate.rst:423
msgid ""
"Above, ``inspected_column`` is a :class:`sqlalchemy.schema.Column` as "
"returned by :meth:`sqlalchemy.engine.reflection.Inspector.reflecttable`, "
"whereas ``metadata_column`` is a :class:`sqlalchemy.schema.Column` from "
"the local model environment.  A return value of ``None`` indicates that "
"default type comparison to proceed."
msgstr ""

#: ../autogenerate.rst:430
msgid ""
"Additionally, custom types that are part of imported or third party "
"packages which have special behaviors such as per-dialect behavior should"
" implement a method called ``compare_against_backend()`` on their "
"SQLAlchemy type.   If this method is present, it will be called where it "
"can also return True or False to specify the types compare as equivalent "
"or not; if it returns None, default type comparison logic will proceed::"
msgstr ""

#: ../autogenerate.rst:455
msgid ""
"The boolean return values for the above ``compare_against_backend`` "
"method, which is part of SQLAlchemy and not Alembic,are **the opposite** "
"of that of the :paramref:`.EnvironmentContext.configure.compare_type` "
"callable, returning ``True`` for types that are the same vs. ``False`` "
"for types that are different.The "
":paramref:`.EnvironmentContext.configure.compare_type` callable on the "
"other hand should return ``True`` for types that are **different**."
msgstr ""

#: ../autogenerate.rst:464
msgid ""
"The order of precedence regarding the "
":paramref:`.EnvironmentContext.configure.compare_type` callable vs. the "
"type itself implementing ``compare_against_backend`` is that the "
":paramref:`.EnvironmentContext.configure.compare_type` callable is "
"favored first; if it returns ``None``, then the "
"``compare_against_backend`` method will be used, if present on the "
"metadata type.  If that returns ``None``, then a basic check for type "
"equivalence is run."
msgstr ""

#: ../autogenerate.rst:472
msgid "- added support for the ``compare_against_backend()`` method."
msgstr ""

